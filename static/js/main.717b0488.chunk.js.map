{"version":3,"sources":["Components/RouteWaypoint.js","Components/RouteInput.js","utility/withCancelToken.js","Components/Centering.js","Components/RouteMap.js","Components/MapRouteCreation.js","Components/App.js","index.js"],"names":["RouteWaypoint","initState","isDragged","state","_this","prevIndex","waypointRef","React","createRef","buttonRef","rafID","isPointerSupported","Boolean","window","PointerEvent","scrollingElement","document","documentElement","_isMounted","updateBaseRect","rect","current","getBoundingClientRect","baseRect","top","scrollTop","bottom","left","scrollLeft","right","props","setWaypointDocCoord","index","handleButtonClick","e","preventDefault","stopPropagation","cancelAnimationFrame","handleDelete","id","updateDraggedState","setState","setDragged","handleGestureStart","touches","length","handleGesture","onPointerDown","onMouseDown","handleButtonDown","this","addEventListener","prevProps","isDragging","waypointClass","react_default","a","createElement","className","Object","assign","style","ref","name","type","Component","RouteInput","text","inputRef","handleChange","target","value","handleKeyDown","key","repeat","trim","handleEnter","isMapLoaded","focus","placeholder","autoComplete","autoCorrect","onChange","onKeyDown","disabled","withCancelToken","token","_ref","asyncToGenerator","regenerator_default","mark","_callee","promise","result","wrap","_context","prev","next","sent","abrupt","t0","stop","_x","apply","arguments","Centering","height","children","RouteMap","isLoading","error","markers","map","polyline","lastAction","isPolylineAnimating","isGoogleApiLoaded","isGeolocationSupported","navigator","googleMapRef","googleMapApiKey","markerColors","start","default","end","addMarker","coordinates","icon","markersCount","marker","setIcon","google","maps","Marker","position","draggable","reverseGeocode","location","geocoder","Geocoder","Promise","resolve","reject","geocode","results","status","console","updatePolyline","setMap","path","getPosition","toJSON","Polyline","geodesic","strokeColor","strokeOpacity","strokeWeight","dragPolylineAnimation","prevState","getLocation","_callee2","_context2","geolocation","getCurrentPosition","Error","lat","lng","withCancel","getGoogleApi","coords","latitude","longitude","center","getDefaultCenter","options","zoom","Map","onMapLoad","_context3","t1","_this2","_this$props$payload","payload","action","newIndex","prevID","newMarkers","getCenter","addListener","requestAnimationFrame","popup","InfoWindow","_callee4","address","content","_context4","concat","formatted_address","setContent","open","toConsumableArray","markerIndex","findIndex","slice","updateMarkerIcon","oldIndex","m","draggedMarker","splice","i","Math","min","max","googleApi","_this3","src","async","onload","onerror","body","appendChild","mapStyle","display","Centering_Centering","message","parseTransformTranslate","transform","x","y","_transform$match","match","MapRouteCreation","isMaxWaypointsReached","waypoints","draggedIndex","mapPayload","isDragAnimating","isDragStarted","canDragStart","startTouchCoord","waypointsRef","WebkitTransform","msTransform","filter","wp","newWaypoints","findDraggedOn","prevGestureCoord","currGestureCoord","every","wpCenter","handleMove","oldRectTop","deltaY","draggedID","draggedWaypoint","handleMapLoad","getCurrentPageCoordinates","changedTouches","pageX","pageY","dragAnimating","deltaX","currentTarget","setPointerCapture","pointerId","handleGestureMove","handleGestureEnd","currPointerCoord","prevPointerCoord","deltaCoordinates","releasePointerCapture","removeEventListener","onPointerMove","onPointerUp","onPointerCancel","onTouchMove","onTouchEnd","src_Components_RouteWaypoint","toString","waypointsClass","mapRouteRef","RouteInput_RouteInput","RouteMap_RouteMap","App","src_Components_MapRouteCreation","ReactDOM","render","src_Components_App","getElementById"],"mappings":"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","file":"static/js/main.717b0488.chunk.js","sourcesContent":["import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport './RouteWaypoint.scss';\r\n\r\n// const throttle = (func, ms) => {\r\n//   let isRunning = false;\r\n//   return (...params) => {\r\n//     if (!isRunning) {\r\n//       isRunning = true;\r\n//       func(...params);\r\n//       setTimeout(() => isRunning = false, ms);\r\n//     }\r\n//   }\r\n// }\r\n\r\nclass RouteWaypoint extends React.Component {\r\n  initState = () => ({\r\n    isDragged: false,\r\n  });\r\n\r\n  state = {\r\n    ...this.initState(),\r\n    prevIndex: null\r\n  }\r\n  waypointRef = React.createRef();\r\n  buttonRef = React.createRef();\r\n  rafID = null;\r\n  isPointerSupported = Boolean(window.PointerEvent);\r\n  scrollingElement = document.scrollingElement || document.documentElement;\r\n  _isMounted = false;\r\n\r\n  updateBaseRect = () => {\r\n    const rect = this.waypointRef.current.getBoundingClientRect();\r\n    const baseRect = {\r\n      top: rect.top + this.scrollingElement.scrollTop,\r\n      bottom: rect.bottom + this.scrollingElement.scrollTop,\r\n      left: rect.left + this.scrollingElement.scrollLeft,\r\n      right: rect.right + this.scrollingElement.scrollLeft\r\n    };\r\n    this.props.setWaypointDocCoord(this.props.index, baseRect);\r\n  }\r\n\r\n\r\n  componentDidMount() {\r\n    this._isMounted = true;\r\n\r\n    this.buttonRef.current.addEventListener('touchstart', this.handleButtonClick, true);\r\n    if (!this.isPointerSupported) {\r\n      // manualy add touch start events because of react bug with chrome\r\n      this.waypointRef.current.addEventListener('touchstart', this.handleGestureStart, true);\r\n    }\r\n    this.updateBaseRect();\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this._isMounted = false;\r\n  }\r\n\r\n  static getDerivedStateFromProps(props, state) {\r\n    if (state.prevIndex === null) {\r\n      return {\r\n        prevIndex: props.index\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    // update baseRect for moved waypoints\r\n    if (this.state.prevIndex !== this.props.index && !this.state.isDragged) {\r\n      this.updateBaseRect();\r\n      this.setState({\r\n        prevIndex: this.props.index\r\n      });\r\n    }\r\n    // update border onGestureEnd\r\n    if (!this.props.isDragging && this.props.isDragging !== prevProps.isDragging && this.state.isDragged) {\r\n      this.setState({\r\n        isDragged: false\r\n      });\r\n    }\r\n  }\r\n\r\n  handleButtonClick = (e) => {\r\n    e.preventDefault();\r\n    e.stopPropagation();\r\n    window.cancelAnimationFrame(this.rafID);\r\n    this.props.handleDelete(this.props.state.id);\r\n  };\r\n\r\n  updateDraggedState = (e) => {\r\n    this.setState({\r\n      isDragged: true\r\n      // posible race condition ?\r\n      // set dragged index on parent\r\n    }, () => this.props.setDragged(this.props.index));\r\n  };\r\n\r\n  handleGestureStart = (e) => {\r\n    e.preventDefault();\r\n    if (e.touches && e.touches.length > 1) return;\r\n    this.updateDraggedState();\r\n  }\r\n\r\n  handleGesture = this.isPointerSupported ? {\r\n    onPointerDown: this.handleGestureStart,\r\n  } : {\r\n      onMouseDown: this.handleGestureStart,\r\n    };\r\n\r\n  handleButtonDown = this.isPointerSupported ? {\r\n    onPointerDown: this.handleButtonClick\r\n  } : {\r\n      onMouseDown: this.handleButtonClick\r\n    }\r\n\r\n  render() {\r\n    const waypointClass = \"route-waypoint__draggable\" + (this.state.isDragged ? \" route-waypoint__draggable_dragging\" : \"\");\r\n    return (\r\n      <div className={\"route-waypoint \" + this.props.className}>\r\n        <div {...this.handleGesture} className={waypointClass} style={this.props.state.style} ref={this.waypointRef}>\r\n          <div className=\"route-waypoint__name\">\r\n            {this.props.state.name}\r\n          </div>\r\n          <button type=\"button\" className=\"route-waypoint__button\" ref={this.buttonRef} {...this.handleButtonDown} />\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nRouteWaypoint.propTypes = {\r\n  index: PropTypes.number,\r\n  state: PropTypes.shape({\r\n    name: PropTypes.string,\r\n    id: PropTypes.number,\r\n    style: PropTypes.shape({\r\n      transform: PropTypes.string,\r\n      WebkitTransform: PropTypes.string,\r\n      msTransform: PropTypes.string\r\n    })\r\n  }),\r\n  className: PropTypes.string,\r\n  handleDelete: PropTypes.func,\r\n  setDragged: PropTypes.func,\r\n  setWaypointDocCoord: PropTypes.func,\r\n  findDraggedOn: PropTypes.func,\r\n  draggedIndex: PropTypes.number,\r\n  isDragging: PropTypes.bool\r\n};\r\n\r\nexport default RouteWaypoint;","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nexport default class RouteInput extends React.Component {\r\n  state = {\r\n    text: ''\r\n  }\r\n\r\n  inputRef = React.createRef();\r\n\r\n  componentDidMount() {\r\n    if (this.props.isMapLoaded) {\r\n      this.inputRef.current.focus();\r\n    }\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    if (prevProps.isMapLoaded !== this.props.isMapLoaded) {\r\n      this.inputRef.current.focus();\r\n    }\r\n  }\r\n\r\n  handleChange = (e) => {\r\n    this.setState({\r\n      text: e.target.value\r\n    });\r\n  }\r\n\r\n  handleKeyDown = (e) => {\r\n    if (e.key === 'Enter' && !e.repeat && e.target.value.trim()) {\r\n      this.props.handleEnter(e.target.value);\r\n      this.setState({\r\n        text: ''\r\n      });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className={this.props.className}>\r\n        <input\r\n          type=\"text\"\r\n          placeholder={this.props.placeholder}\r\n          autoComplete=\"off\"\r\n          autoCorrect=\"off\"\r\n          onChange={this.handleChange}\r\n          onKeyDown={this.handleKeyDown}\r\n          value={this.state.text}\r\n          ref={this.inputRef}\r\n          disabled={this.props.isMapLoaded ? false : true}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nRouteInput.propTypes = {\r\n  className: PropTypes.string,\r\n  handleEnter: PropTypes.func,\r\n  placeholder: PropTypes.string,\r\n  isMapLoaded: PropTypes.bool\r\n};","const withCancelToken = (token) => async (promise) => {\r\n  try {\r\n    const result = await promise;\r\n    if (!token.value) {\r\n      throw Object({ type: 'CANCELED' });\r\n    }\r\n    return result;\r\n  } catch (err) {\r\n    throw token.value ? err : { type: 'CANCELED' };\r\n  }\r\n};\r\n\r\nexport default withCancelToken;","import React from 'react';\r\nimport './Centering.scss';\r\n\r\nexport default class Centering extends React.Component {\r\n  render() {\r\n    return (\r\n      <div className=\"centering-outer\" style={{ height: this.props.height }}>\r\n        <div className=\"centering-middle\">\r\n          {this.props.children}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n","import React from 'react';\r\nimport withCancelToken from '../utility/withCancelToken';\r\nimport PropTypes from 'prop-types';\r\nimport './RouteMap.scss';\r\nimport Centering from './Centering';\r\n\r\nexport default class RouteMap extends React.Component {\r\n\r\n  state = {\r\n    isLoading: true,\r\n    error: null,\r\n    markers: [],\r\n    map: null,\r\n    polyline: null,\r\n    lastAction: null\r\n    // viewport: {\r\n    //   height: '',\r\n    //   width: ''\r\n    // }\r\n  }\r\n  isPolylineAnimating = false;\r\n  // scrollingElement = document.scrollingElement || document.documentElement;\r\n\r\n  _isMounted = { value: false }; // cancel token\r\n  isGoogleApiLoaded = 'google' in window;\r\n  isGeolocationSupported = \"geolocation\" in navigator;\r\n\r\n  googleMapRef = React.createRef();\r\n  googleMapApiKey = \"AIzaSyC3BmUjtcRlGyF4IXIuW0daNjoSFjDnRxA\";\r\n\r\n  markerColors = {\r\n    start: 'http://maps.google.com/mapfiles/ms/icons/green-dot.png',\r\n    default: 'http://maps.google.com/mapfiles/ms/icons/yellow-dot.png',\r\n    end: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png'\r\n  }\r\n\r\n  getDefaultCenter() {\r\n    return { lat: 55.7558, lng: 37.6173 };\r\n  }\r\n\r\n  addMarker = (coordinates) => {\r\n    let icon;\r\n    const markersCount = this.state.markers.length;\r\n    if (!markersCount) {\r\n      icon = this.markerColors.start;\r\n    } else {\r\n      icon = this.markerColors.end;\r\n      if (markersCount !== 1) {\r\n        this.state.markers[markersCount - 1].marker.setIcon(this.markerColors.default);\r\n      }\r\n    }\r\n    return new window.google.maps.Marker({\r\n      position: coordinates,\r\n      map: this.state.map,\r\n      draggable: true,\r\n      icon\r\n    });\r\n  }\r\n\r\n  updateMarkerIcon(markers, index) {\r\n    if (index === 0) {\r\n      markers[index].marker.setIcon(this.markerColors.start);\r\n    } else if (index === markers.length - 1) {\r\n      markers[index].marker.setIcon(this.markerColors.end);\r\n    } else if (index < markers.length - 1) {\r\n      markers[index].marker.setIcon(this.markerColors.default);\r\n    }\r\n  }\r\n\r\n  // updateViewPortSize = () => {\r\n  //   this.setState({\r\n  //     viewport: {\r\n  //       height: this.scrollingElement.clientHeight,\r\n  //       width: this.scrollingElement.clientWidth\r\n  //     }\r\n  //   });\r\n  // }\r\n\r\n  async componentDidMount() {\r\n    // this.updateViewPortSize();\r\n    // window.addEventListener('resize', this.updateViewPortSize);\r\n\r\n    this._isMounted.value = true;\r\n    this.withCancel = withCancelToken(this._isMounted);\r\n    try {\r\n      if (!this.isGoogleApiLoaded) {\r\n        await this.withCancel(this.getGoogleApi());\r\n        this.isGoogleApiLoaded = true;\r\n      }\r\n      let center;\r\n      if (this.isGeolocationSupported) {\r\n        try {\r\n          const { coords: { latitude, longitude } } = await this.withCancel(this.getLocation());\r\n          center = { lat: latitude, lng: longitude }\r\n        } catch (e) {\r\n        }\r\n      }\r\n      if (!center) center = this.getDefaultCenter();\r\n      const options = {\r\n        center,\r\n        zoom: 8\r\n      }\r\n      const map = new window.google.maps.Map(this.googleMapRef.current, options);\r\n      this.setState({ map });\r\n      this.props.onMapLoad();\r\n    } catch (error) {\r\n      if (error.type === 'CANCELED') return;\r\n      this.setState({\r\n        error\r\n      });\r\n    } finally {\r\n      this.setState({\r\n        isLoading: false\r\n      })\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this._isMounted.value = false;\r\n  }\r\n\r\n  componentDidUpdate(prevProps, prevState) {\r\n    const { id, action, name, newIndex } = this.props.payload;\r\n    const { id: prevID } = prevProps.payload;\r\n    let newMarkers = null;\r\n    if (action === 'ADD' && id !== prevID) {\r\n      // ADD marker block\r\n      // create and add marker to the map\r\n      const coordinates = this.state.map.getCenter().toJSON();\r\n      const marker = this.addMarker(coordinates);\r\n      // add event listener to marker to animate polyline on drag\r\n      marker.addListener('drag', () => {\r\n        this.isPolylineAnimating = true;\r\n        window.requestAnimationFrame(this.dragPolylineAnimation);\r\n      });\r\n      // create popup\r\n      const popup = new window.google.maps.InfoWindow();\r\n      // add popup to the marker\r\n      marker.addListener('click', async () => {\r\n        const coordinates = marker.getPosition().toJSON();\r\n        const address = await this.reverseGeocode(coordinates);\r\n        const content = `\r\n        <div class=\"route-map__popup\">\r\n          <div class=\"route-map__popup__name\">${name}</div>\r\n          ${address ? `<div class=\"route-map__popup__address\">${address.formatted_address}</div>` : ``}\r\n        </div>`;\r\n        popup.setContent(content);\r\n        popup.open(this.state.map, marker)\r\n      });\r\n      //add marker to markers array\r\n      newMarkers = [...this.state.markers, { id, marker }];\r\n    } else if (action === 'DELETE' && prevState.markers.length === this.state.markers.length) {\r\n      // DELETE marker block\r\n      const markerIndex = this.state.markers.findIndex(marker => marker.id === id);\r\n      if (markerIndex === -1) return;\r\n      this.state.markers[markerIndex].marker.setMap(null);\r\n      newMarkers = [...this.state.markers.slice(0, markerIndex), ...this.state.markers.slice(markerIndex + 1)];\r\n      if (markerIndex === newMarkers.length && newMarkers.length !== 0) {\r\n        // if last item has been deleted than update only last marker of a non empty array\r\n        this.updateMarkerIcon(newMarkers, newMarkers.length - 1);\r\n      } else if (!markerIndex && newMarkers.length !== 0) {\r\n        // if first item has been deleted than update only first marker of a non empty array \r\n        this.updateMarkerIcon(newMarkers, 0);\r\n      }\r\n    } else if (action === 'MOVE' && this.state.markers[newIndex].id !== id) {\r\n      // MOVE marker block\r\n      const oldIndex = this.state.markers.findIndex(m => m.id === id);\r\n      newMarkers = [...this.state.markers];\r\n      const draggedMarker = newMarkers.splice(oldIndex, 1)[0];\r\n      newMarkers.splice(newIndex, 0, draggedMarker);\r\n      for (let i = Math.min(oldIndex, newIndex); i <= Math.max(oldIndex, newIndex); i++) {\r\n        this.updateMarkerIcon(newMarkers, i);\r\n      }\r\n    }\r\n    // get new polyline\r\n    let polyline;\r\n    if ((newMarkers && newMarkers.length !== this.state.markers.length) || (action === 'MOVE' && this.state.markers[newIndex].id !== id)) {\r\n\r\n      polyline = this.updatePolyline(newMarkers);\r\n      this.setState({\r\n        markers: newMarkers,\r\n        polyline,\r\n        lastAction: action\r\n      });\r\n    }\r\n    if (this.state.lastAction === 'POLYLINE') {\r\n      this.setState({\r\n        lastAction: null\r\n      })\r\n    }\r\n  }\r\n\r\n  reverseGeocode = async (location) => {\r\n    try {\r\n      const geocoder = new window.google.maps.Geocoder();\r\n      return await new Promise((resolve, reject) => {\r\n        geocoder.geocode({ 'location': location }, (results, status) => {\r\n          if (status === 'OK') {\r\n            resolve(results[0]);\r\n          } else {\r\n            reject(status);\r\n          }\r\n        });\r\n      });\r\n    }\r\n    catch (err) {\r\n      console.error('reverse geocode error caught', err);\r\n    }\r\n  }\r\n\r\n\r\n  updatePolyline = (markers) => {\r\n    // clear polyline\r\n    if (this.state.polyline) this.state.polyline.setMap(null);\r\n    // draw lines if more than 1 marker\r\n    if (markers.length > 1) {\r\n      // get path array\r\n      const path = markers.map(marker => marker.marker.getPosition().toJSON());\r\n      // create new polyline\r\n      const polyline = new window.google.maps.Polyline({\r\n        path,\r\n        geodesic: true,\r\n        strokeColor: '#FF0000',\r\n        strokeOpacity: 1.0,\r\n        strokeWeight: 2\r\n      });\r\n      polyline.setMap(this.state.map);\r\n      return polyline;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  dragPolylineAnimation = () => {\r\n    if (!this.isPolylineAnimating || !this._isMounted) return;\r\n    this.setState(prevState => {\r\n      const polyline = this.updatePolyline(prevState.markers);\r\n      return {\r\n        polyline,\r\n        lastAction: 'POLYLINE'\r\n      }\r\n    }, () => this.isPolylineAnimating = false);\r\n\r\n  }\r\n\r\n  async getGoogleApi() {\r\n    try {\r\n      return await new Promise((resolve, reject) => {\r\n        const googleApi = document.createElement('script');\r\n        const key = this.googleMapApiKey;\r\n        googleApi.src = `https://maps.googleapis.com/maps/api/js?key=${key}`;\r\n        googleApi.type = \"text/javascript\";\r\n        googleApi.async = false;\r\n        googleApi.onload = (e) => resolve('google api loaded');\r\n        googleApi.onerror = (e) => reject(new Error(e));\r\n        document.body.appendChild(googleApi);\r\n      });\r\n    } catch (err) {\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  getLocation = async () => {\r\n    try {\r\n      const position =\r\n        await new Promise((resolve, reject) => {\r\n          navigator.geolocation.getCurrentPosition(\r\n            location => resolve(location),\r\n            () => reject(Error('geolocation blocked'))\r\n          );\r\n        });\r\n      return position;\r\n    }\r\n    catch (err) {\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const mapStyle = this.state.isLoading || this.state.error ? { display: 'none' } : { display: 'block' };\r\n    // const mapStyle = {\r\n    //   ...this.state.viewport\r\n    // }\r\n    return (\r\n      <div className={\"route-map \" + this.props.className}>\r\n        {this.state.isLoading && <Centering><div className=\"route-map__loading\">Loading</div></Centering>}\r\n        {this.state.error && <Centering><div className=\"route-map__error\">{this.state.error.message}</div></Centering>}\r\n        <div className=\"route-map__map\" style={mapStyle} ref={this.googleMapRef} />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nRouteMap.propTypes = {\r\n  className: PropTypes.string,\r\n  payload: PropTypes.shape({\r\n    id: PropTypes.number,\r\n    name: PropTypes.string,\r\n    action: PropTypes.string,\r\n    newIndex: PropTypes.number\r\n  }),\r\n};","import React from 'react';\r\nimport RouteWaypoint from './RouteWaypoint';\r\nimport RouteInput from './RouteInput';\r\nimport RouteMap from './RouteMap';\r\nimport Centering from './Centering';\r\nimport './MapRouteCreation.scss';\r\n\r\nexport const parseTransformTranslate = (transform) => {\r\n  if (!transform) return { x: 0, y: 0 };\r\n  const { 0: x, 1: y } = transform.match(/-?\\d+(\\.\\d+)?/g);\r\n  return { x: +x, y: +y };\r\n}\r\n\r\n\r\nclass MapRouteCreation extends React.Component {\r\n\r\n  state = {\r\n    isMaxWaypointsReached: false,\r\n    isMapLoaded: false,\r\n    waypoints: [],\r\n    id: 0,\r\n    draggedIndex: null,\r\n    mapPayload: {\r\n      id: null,\r\n      newIndex: null,\r\n      action: '',\r\n      name: ''\r\n    },\r\n    isDragAnimating: false,\r\n    isDragStarted: false,\r\n    canDragStart: false\r\n  };\r\n\r\n  startTouchCoord = null;\r\n  isPointerSupported = Boolean(window.PointerEvent);\r\n\r\n  waypointsRef = React.createRef()\r\n\r\n  componentDidMount() {\r\n    this._isMounted = true;\r\n    this.handleGesture = this.isPointerSupported ?\r\n      {\r\n        onPointerDown: this.handleGestureStart,\r\n        onPointerMove: this.handleGestureMove,\r\n        onPointerUp: this.handleGestureEnd,\r\n        onPointerCancel: this.handleGestureEnd\r\n      } : {\r\n        onMouseDown: this.handleGestureStart,\r\n        onTouchMove: this.handleGestureMove,\r\n        onTouchEnd: this.handleGestureEnd,\r\n      };\r\n    if (!this.isPointerSupported) {\r\n      // manualy add touch start events because of react bug with chrome\r\n      this.waypointsRef.current.addEventListener('touchstart', this.handleGestureStart);\r\n    }\r\n\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this._isMounted = false;\r\n  }\r\n\r\n  handleEnter = (value) => {\r\n    this.setState(prevState => {\r\n      if (prevState.waypoints.length === 15) {\r\n        return {\r\n          isMaxWaypointsReached: true\r\n        };\r\n      }\r\n      return {\r\n        waypoints: [...prevState.waypoints, {\r\n          name: value,\r\n          id: prevState.id,\r\n          style: {\r\n            transform: ``,\r\n            WebkitTransform: ``,\r\n            msTransform: ``\r\n          }\r\n        }],\r\n        id: prevState.id + 1,\r\n        mapPayload: {\r\n          id: prevState.id,\r\n          action: 'ADD',\r\n          name: value,\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  handleDelete = (id) => {\r\n    this.setState(prevState => ({\r\n      waypoints: prevState.waypoints.filter(wp => wp.id !== id),\r\n      isMaxWaypointsReached: false,\r\n      mapPayload: {\r\n        id: id,\r\n        action: 'DELETE'\r\n      }\r\n    }));\r\n  };\r\n\r\n  setWaypointDocCoord = (index, baseRect) => {\r\n    const newWaypoints = [...this.state.waypoints];\r\n    newWaypoints[index].baseRect = baseRect;\r\n    this.setState({\r\n      waypoints: newWaypoints\r\n    });\r\n  }\r\n\r\n  findDraggedOn = (prevGestureCoord, currGestureCoord) => {\r\n    this.state.waypoints.every((wp, index) => {\r\n      if (wp.id === this.state.waypoints[this.state.draggedIndex].id) {\r\n        return true;\r\n      }\r\n      const wpCenter = (wp.baseRect.top + wp.baseRect.bottom) / 2;\r\n      if (wpCenter <= Math.max(prevGestureCoord.y, currGestureCoord.y) &&\r\n        wpCenter >= Math.min(prevGestureCoord.y, currGestureCoord.y) &&\r\n        wp.baseRect.left <= currGestureCoord.x &&\r\n        wp.baseRect.right >= currGestureCoord.x) {\r\n        this.handleMove(index);\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n  };\r\n\r\n  setDragged = (index) => {\r\n    this.setState({\r\n      canDragStart: true,\r\n      draggedIndex: index,\r\n      mapPayload: {\r\n        action: ''\r\n      }\r\n    });\r\n  }\r\n\r\n  handleMove = (newIndex) => {\r\n    this.setState(prevState => {\r\n      let newWaypoints = [...prevState.waypoints];\r\n      const oldIndex = prevState.draggedIndex;\r\n      const { top: oldRectTop } = newWaypoints[oldIndex].baseRect;\r\n      const { top: newRectTop } = newWaypoints[newIndex].baseRect;\r\n      const deltaY = newRectTop - oldRectTop;\r\n      this.startTouchCoord = {\r\n        x: this.startTouchCoord.x,\r\n        y: this.startTouchCoord.y + deltaY\r\n      }\r\n\r\n      const { x } = parseTransformTranslate(newWaypoints[oldIndex].style.transform);\r\n\r\n      const transform = `translate(${x}px, ${0}px)`;\r\n      newWaypoints[prevState.draggedIndex].style = {\r\n        transform: transform,\r\n        WebkitTransform: transform,\r\n        msTransform: transform\r\n      };\r\n\r\n      const draggedID = prevState.waypoints[oldIndex].id;\r\n      // get new baseRect for dragging waypoint so we can properly animate\r\n      newWaypoints[oldIndex].baseRect = newWaypoints[newIndex].baseRect;\r\n      const draggedWaypoint = newWaypoints.splice(oldIndex, 1)[0];\r\n      newWaypoints.splice(newIndex, 0, draggedWaypoint);\r\n      window.cancelAnimationFrame(this.rafID);\r\n      return {\r\n        isDragAnimating: false,\r\n        draggedIndex: newIndex,\r\n        waypoints: newWaypoints,\r\n        mapPayload: {\r\n          id: draggedID,\r\n          newIndex,\r\n          action: 'MOVE'\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  handleMapLoad = () => this.setState({\r\n    isMapLoaded: true\r\n  });\r\n\r\n  getCurrentPageCoordinates = (e) => {\r\n    return e.touches && e.changedTouches[0] ? // check if touch event\r\n      {\r\n        x: e.changedTouches[0].pageX,\r\n        y: e.changedTouches[0].pageY\r\n      } : {\r\n        x: e.pageX,\r\n        y: e.pageY\r\n      };\r\n  }\r\n  // drag animation on touch move\r\n  dragAnimating = ({ x: deltaX, y: deltaY }) => {\r\n    if (!this._isMounted || !this.state.isDragAnimating) return;\r\n    this.setState(prevState => {\r\n      const newWaypoints = [...prevState.waypoints];\r\n      const transform = `translate(${deltaX}px, ${deltaY}px)`;\r\n      newWaypoints[prevState.draggedIndex].style = {\r\n        transform: transform,\r\n        WebkitTransform: transform,\r\n        msTransform: transform\r\n      }\r\n      return {\r\n        waypoints: newWaypoints,\r\n      }\r\n    }, () => {\r\n      this.setState({\r\n        isDragAnimating: false\r\n      });\r\n    });\r\n  }\r\n\r\n  handleGestureStart = (e) => {\r\n    e.preventDefault();\r\n    if (e.touches && e.touches.length > 1) return;\r\n    if (this.isPointerSupported) {\r\n      e.currentTarget.setPointerCapture(e.pointerId);\r\n    } else {\r\n      document.addEventListener('mousemove', this.handleGestureMove, true);\r\n      document.addEventListener('mouseup', this.handleGestureEnd, true);\r\n    }\r\n\r\n    this.startTouchCoord = this.getCurrentPageCoordinates(e);\r\n    this.currPointerCoord = this.startTouchCoord;\r\n    this.setState({\r\n      isDragStarted: true\r\n    });\r\n  };\r\n\r\n  handleGestureMove = (e) => {\r\n    if (!this.state.canDragStart) return;\r\n\r\n    e.preventDefault();\r\n    if (!this.state.isDragStarted) return;\r\n    if (!this.state.isDragAnimating) {\r\n      this.setState({\r\n        isDragAnimating: true\r\n      });\r\n      this.prevPointerCoord = this.currPointerCoord;\r\n      this.currPointerCoord = this.getCurrentPageCoordinates(e);\r\n      const deltaCoordinates = {\r\n        x: this.currPointerCoord.x - this.startTouchCoord.x,\r\n        y: this.currPointerCoord.y - this.startTouchCoord.y\r\n      }\r\n      this.findDraggedOn(this.prevPointerCoord, this.currPointerCoord);\r\n      // if (this.haveFoundDraggedOn) return;\r\n      // this.throttledFindDraggedOn(this.prevPointerCoord, this.currPointerCoord);\r\n      this.rafID = window.requestAnimationFrame(() => this.dragAnimating(deltaCoordinates));\r\n    }\r\n  }\r\n\r\n  handleGestureEnd = (e) => {\r\n    e.preventDefault();\r\n    if (e.touches && e.touches.length > 0) {\r\n      return;\r\n    }\r\n\r\n    // Remove Event Listeners\r\n    if (this.isPointerSupported) {\r\n      e.currentTarget.releasePointerCapture(e.pointerId);\r\n    } else {\r\n      // Remove Mouse Listeners\r\n      document.removeEventListener('mousemove', this.handleGestureMove, true);\r\n      document.removeEventListener('mouseup', this.handleGestureEnd, true);\r\n    }\r\n\r\n    this.setState(prevState => {\r\n      const newWaypoints = [...prevState.waypoints];\r\n      if (newWaypoints[prevState.draggedIndex]) {\r\n        newWaypoints[prevState.draggedIndex].style = {\r\n          transform: '',\r\n          WebkitTransform: '',\r\n          msTransform: ''\r\n        };\r\n      }\r\n      return {\r\n        newWaypoints,\r\n        draggedIndex: null,\r\n        isDragStarted: false,\r\n        canDragStart: false,\r\n        isDragAnimating: false\r\n      }\r\n    });\r\n    this.rafID = null;\r\n  }\r\n\r\n\r\n  render() {\r\n    const waypoints = this.state.waypoints.map((wp, index) =>\r\n      <RouteWaypoint\r\n        key={wp.id.toString()}\r\n        index={index}\r\n        state={wp}\r\n        className=\"map-route-creation__waypoint\"\r\n        handleDelete={this.handleDelete}\r\n        setDragged={this.setDragged}\r\n        draggedIndex={this.state.draggedIndex}\r\n        isDragging={this.state.isDragStarted}\r\n        setWaypointDocCoord={this.setWaypointDocCoord}\r\n        findDraggedOn={this.findDraggedOn}\r\n      />\r\n    );\r\n    const waypointsClass = \"map-route-creation__waypoints \" + (this.state.isDragStarted ? \"map-route-creation__waypoints_dragging\" : \"\");\r\n    return (\r\n      <Centering height=\"100vh\">\r\n        <div className=\"map-route-creation\" ref={this.mapRouteRef}>\r\n          <div className=\"map-route-creation__content\" >\r\n            <RouteInput className=\"map-route-creation__input\" handleEnter={this.handleEnter} placeholder=\"Новая точка маршрута\" isMapLoaded={this.state.isMapLoaded} />\r\n            <div className={waypointsClass} {...this.handleGesture} ref={this.waypointsRef}>\r\n              {waypoints}\r\n            </div>\r\n            {this.state.isMaxWaypointsReached && <div className=\"map-route-creation__warning\">15 точек максимум</div>}\r\n          </div>\r\n          <RouteMap className=\"map-route-creation__map\" payload={this.state.mapPayload} onMapLoad={this.handleMapLoad} />\r\n        </div>\r\n      </Centering>\r\n    );\r\n  }\r\n}\r\n\r\nexport default MapRouteCreation;","import React, { Component } from 'react';\nimport './App.scss';\nimport MapRouteCreation from './MapRouteCreation';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <MapRouteCreation />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import 'react-app-polyfill/ie9';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './Components/App';\n\nReactDOM.render(\n  <App />\n  ,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}