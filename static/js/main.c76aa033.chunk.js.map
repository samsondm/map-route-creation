{"version":3,"sources":["utility/rAFTranslate.ts","utility/parseTranslate.js","Components/RouteWaypoint.js","utility/rAFThrottle.js","Components/RouteInput.js","utility/withAbortToken.js","Components/Centering.js","Components/RouteMap.js","utility/rectangle-utility.ts","Components/MapRouteCreation.js","Components/App.js","index.js"],"names":["easeOutQuad","t","rAFTranslate","props","callback","passedTime","timeLeft","startTime","duration","_props$startCoord","startCoord","startX","x","startY","y","_props$endCoord","endCoord","endX","endY","timingFunc","nodeStyle","distanceX","distanceY","rafID","window","requestAnimationFrame","rAF","now","passedNormTime","passedDistanceX","passedDistanceY","transform","concat","cancel","cancelAnimationFrame","getPassedTime","getTimeLeft","arrayToRegExp","array","RegExp","map","r","source","join","parseTranslate","translatePropsRgx","test","z","type","match","length","_match$","_match$2","_match$3","getMovedDistance","_ref","arguments","undefined","prevX","prevY","_ref2","currX","currY","Math","sqrt","pow","RouteWaypoint","state","transitionTime","prevIndex","sloppyClick","hasDragged","isDragging","longTouchTimeoutID","longTouchWait","moveTriggerDelta","startGestureCoord","draggedOnRAFTranslate","routeWaypointRef","React","createRef","waypointRef","buttonRef","iconRef","isPointerSupported","Boolean","PointerEvent","scrollingElement","document","documentElement","_isMounted","updateBaseRect","rect","_this","current","getBoundingClientRect","baseRect","top","scrollTop","bottom","left","scrollLeft","right","setBaseRect","index","handleButtonClick","e","isTransitioning","preventDefault","cancelLongTouch","handleDelete","id","getCurrGesturePageCoord","touches","changedTouches","pageX","pageY","dragUpdate","translationVector","currGestureCoord","dragAnimating","updateWaypoints","updateWaypointStyle","transition","style","WebkitTransition","WebkitTransform","msTransform","Object","assign","_ref3","deltaX","deltaY","clearTimeout","handleGestureStart","hasGestureStarted","currentTarget","setPointerCapture","pointerId","addEventListener","handleGestureMove","handleGestureEnd","setTimeout","setDragged","dragUpdateThrottled","releasePointerCapture","removeEventListener","draggedCurrRect","performance","handleMoveEnd","handleGesture","onPointerDown","onPointerMove","onPointerUp","onPointerCancel","onMouseDown","onTouchMove","onTouchEnd","this","func","latestArgs","raf","_len","args","Array","_key","apply","toConsumableArray","rAFThrottle","nextProps","nextState","prevProps","prevState","rafTransition","_ref4","_ref5","slicedToArray","waypointStyle","waypointClass","iconClass","react_default","a","createElement","className","ref","name","onClick","Component","RouteInput","text","inputRef","handleChange","setState","target","value","handleKeyDown","key","repeat","trim","handleEnter","isMapLoaded","focus","click","placeholder","autoComplete","autoCorrect","onChange","onKeyDown","disabled","withAbortToken","abortToken","promise","Promise","resolve","reject","abort","then","catch","reason","Centering","height","children","RouteMap","isLoading","error","markers","polyline","lastAction","isPolylineAnimating","isGoogleApiLoaded","isGeolocationSupported","navigator","googleMapRef","googleMapApiKey","markerColors","start","default","end","addMarker","coordinates","icon","markersCount","marker","setIcon","google","maps","Marker","position","draggable","reverseGeocode","_callee","location","geocoder","regenerator_default","wrap","_context","prev","next","Geocoder","geocode","results","status","abrupt","sent","t0","stop","updatePolyline","setMap","path","getPosition","toJSON","Polyline","geodesic","strokeColor","strokeOpacity","strokeWeight","dragPolylineAnimation","getLocation","_callee2","_context2","geolocation","getCurrentPosition","Error","lat","lng","withCancel","getGoogleApi","coords","latitude","longitude","center","getDefaultCenter","options","zoom","Map","onMapLoad","_context3","t1","_this2","_this$props$payload","payload","action","newIndex","prevID","newMarkers","getCenter","addListener","popup","InfoWindow","asyncToGenerator","mark","_callee4","address","content","_context4","formatted_address","setContent","open","markerIndex","findIndex","slice","updateMarkerIcon","oldIndex","m","draggedMarker","splice","i","min","max","googleApi","_this3","src","async","onload","onerror","body","appendChild","mapStyle","display","Centering_Centering","message","isRect","calcRectArea","calcIntersectionRect","rect1","rect2","doRectIntersect","MapRouteCreation","hasMoved","isMaxWaypointsReached","waypoints","draggedIndex","mapPayload","waypointsRects","filter","wp","draggedCurrIndex","_this$state","draggedOnIndex","findDraggedOn","handleMove","wpAreaFraction","_this$state2","every","draggedBaseRect","draggedRect","draggedOnRect","intersectionRect","newWaypoints","initIndex","currIndex","isNewInside","isNewOutSide","isGoingUP","objectSpread","draggedID","draggedWaypoint","handleMapLoad","src_Components_RouteWaypoint","toString","waypointsClass","isDragStarted","RouteInput_RouteInput","RouteMap_RouteMap","App","MapRouteCreation_MapRouteCreation","ReactDOM","render","src_Components_App","getElementById"],"mappings":"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","file":"static/js/main.c76aa033.chunk.js","sourcesContent":["type TimingFunction = (t: number) => number;\n\nconst easeOutQuad: TimingFunction = t => t * (2 - t); // timing function\n\ntype Point2D = {\n  x: number;\n  y: number;\n};\n\ninterface IProps {\n  startTime: number;\n  duration: number;\n  startCoord: Point2D;\n  endCoord: Point2D;\n  timingFunc: TimingFunction;\n  nodeStyle: CSSStyleDeclaration;\n}\n// TODO: move calculation of startCoord into function\nfunction rAFTranslate(props: IProps, callback: Function) {\n  if (!props) return;\n  const {\n    startTime,\n    duration,\n    startCoord: { x: startX, y: startY },\n    endCoord: { x: endX, y: endY },\n    timingFunc,\n    nodeStyle,\n  } = props;\n  const distanceX = endX - startX;\n  const distanceY = endY - startY;\n  let rafID: number | null = null;\n  let passedTime: number, timeLeft: number;\n\n  const cancel = (): void => {\n    if (!rafID) return;\n    window.cancelAnimationFrame(rafID);\n    rafID = null;\n  };\n\n  const getPassedTime = () => passedTime;\n  const getTimeLeft = () => timeLeft;\n\n  const rAF = (now: number) => {\n    passedTime = now - startTime;\n    passedTime = passedTime >= 0 ? passedTime : 0;\n    timeLeft = duration - passedTime;\n    const passedNormTime = passedTime / duration;\n    const passedDistanceX = timingFunc(passedNormTime) * distanceX;\n    const passedDistanceY = timingFunc(passedNormTime) * distanceY;\n\n    nodeStyle.transform = `translate3d(${startX + passedDistanceX}px, ${startY +\n      passedDistanceY}px, ${0}px)`;\n    if (passedNormTime >= 1) {\n      nodeStyle.transform = `translate3d(${endX}px, ${endY}px, ${0}px)`;\n      passedTime = duration;\n      timeLeft = 0;\n      if (callback) callback();\n      return;\n    }\n    rafID = window.requestAnimationFrame(rAF);\n  };\n  rafID = window.requestAnimationFrame(rAF);\n  return {\n    cancel,\n    getPassedTime,\n    getTimeLeft,\n  };\n}\n\nexport { easeOutQuad };\nexport default rAFTranslate;\n","const arrayToRegExp = (array) => new RegExp(array.map(r => r.source).join(''));\n\nexport default function parseTranslate(transform) {\n  const translatePropsRgx = new RegExp(\n    `(` +      // opening of capturing parentesis for props\n    `\\\\s*` +    // preceding white space\n    `-?` +     // sign\n    `(` + // opening capturing parentesis for length\n    `((?!0)\\\\d+(?:\\\\.\\\\d+)?|0?\\\\.\\\\d+|)` + // not 0 number\n    `px{1}` + // unit\n    `|` + // or\n    `0(px)?` + // 0\n    `)` + // closing capturing parentesis for length\n    `\\\\s*` +    // subsequent white space\n    `,?` +     // comma\n    `)` +      // closing of capturing parentesis for props\n    `{1,3}`   // number of props\n  );\n  const translateRgx = arrayToRegExp([\n    /translate/,    // translate\n    /(3d|[XYZ])?/,  // type\n    /\\(/,           // opening parentesis\n    translatePropsRgx,\n    /\\)$/           // closing parentesis\n  ]);\n  const valid = translateRgx.test(transform);\n  if (!valid) return null;\n  let x = 0,\n    y = 0,\n    z = 0;\n  const type = transform.match(/(?:3d|[XYZ])?(?=\\()/)[0];\n  const match = transform.match(/-?(\\d+(?:\\.\\d+)?|\\.\\d+)(?!d)/g);\n  if (type === 'X') {\n    if (match.length !== 1) return null;\n    x = match[0];\n  } else if (type === 'Y') {\n    if (match.length !== 1) return null;\n    y = match[0];\n  } else if (type === 'Z') {\n    if (match.length !== 1) return null;\n    z = match[0];\n  } else {\n    if (type === '' && match.length > 2) return null;\n    z = match[0];\n    ({ 0: x = 0, 1: y = 0, 2: z = 0 } = match);\n  }\n  return { x: +x, y: +y, z: +z };\n}","import React from 'react';\nimport PropTypes from 'prop-types';\nimport './RouteWaypoint.scss';\nimport rAFThrottle from '../utility/rAFThrottle';\nimport rAFTranslate, { easeOutQuad } from '../utility/rAFTranslate';\nimport parseTranslate from '../utility/parseTranslate';\n\nconst getMovedDistance = (\n  { x: prevX, y: prevY } = {},\n  { x: currX, y: currY } = {},\n) =>\n  prevX !== undefined &&\n  prevY !== undefined &&\n  currX !== undefined &&\n  currY !== undefined\n    ? Math.sqrt(Math.pow(currX - prevX, 2) + Math.pow(currY - prevY, 2))\n    : null;\n\nclass RouteWaypoint extends React.Component {\n  state = {\n    transitionTime: 0,\n    transform: `translate3d(${0}px, ${0}px, 0)`,\n    prevIndex: null,\n  };\n\n  sloppyClick = true;\n  hasDragged = false;\n  isDragging = false;\n  longTouchTimeoutID = null;\n  longTouchWait = 200;\n  moveTriggerDelta = 3; // how far should the cursor move from startTouch to trigger drag\n  startGestureCoord = null;\n\n  draggedOnRAFTranslate = null;\n\n  routeWaypointRef = React.createRef();\n  waypointRef = React.createRef();\n  buttonRef = React.createRef();\n  iconRef = React.createRef();\n\n  isPointerSupported = Boolean(window.PointerEvent);\n  scrollingElement = document.scrollingElement || document.documentElement;\n  _isMounted = false;\n\n  updateBaseRect = () => {\n    const rect = this.routeWaypointRef.current.getBoundingClientRect();\n    this.baseRect = {\n      top: rect.top + this.scrollingElement.scrollTop,\n      bottom: rect.bottom + this.scrollingElement.scrollTop,\n      left: rect.left + this.scrollingElement.scrollLeft,\n      right: rect.right + this.scrollingElement.scrollLeft,\n    };\n    this.props.setBaseRect(this.props.index, this.baseRect);\n  };\n\n  componentDidMount() {\n    this._isMounted = true;\n    this.dragUpdateThrottled = rAFThrottle(this.dragUpdate);\n\n    this.buttonRef.current.addEventListener(\n      'touchstart',\n      this.handleButtonClick,\n      true,\n    );\n    if (!this.isPointerSupported) {\n      // manualy add touch start events because react puts events on document\n      // and chrome calls top level event handler with passive flag for scroll performance\n      // so we wont be able to call preventDefault\n      this.iconRef.current.addEventListener(\n        'touchstart',\n        this.handleGestureStart,\n      );\n    }\n    // store base rect in parent state for collision detection\n    this.updateBaseRect();\n    // update base rects on window resize\n    window.addEventListener('resize', this.updateBaseRect);\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n    window.removeEventListener('resize', this.updateBaseRect);\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (\n      this.props.draggedCurrRect !== nextProps.draggedCurrRect ||\n      this.props.state.transform !== nextProps.state.transform ||\n      this.state.transform !== nextState.transform ||\n      this.props.index !== nextProps.index ||\n      ((this.isDragging || this.hasDragged) &&\n        nextProps.isTransitioning !== this.props.isTransitioning)\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    // update baseRect if waypoint changed position\n    if (this.props.index !== prevProps.index) {\n      if (this.rafTransition) {\n        window.cancelAnimationFrame(this.rafTransition);\n        this.rafTransition = null;\n      }\n      this.updateBaseRect();\n    }\n    // update dragged waypoint on transition end\n    if (\n      this.hasDragged &&\n      !this.props.isTransitioning &&\n      prevProps.isTransitioning !== this.props.isTransitioning\n    ) {\n      this.hasDragged = false;\n    }\n    // update wp that moved when dragged on wp was found\n    if (\n      prevProps.state.transform !== this.props.state.transform &&\n      !this.isDragging &&\n      !this.hasDragged &&\n      this.props.isTransitioning\n    ) {\n      // cancel current transition\n      if (this.draggedOnRAFTranslate) {\n        this.draggedOnRAFTranslate.cancel();\n      }\n      // start new transition\n      const transitionTime = this.props.state.transitionTime;\n      const timeLeft = !this.draggedOnRAFTranslate\n        ? 0\n        : this.draggedOnRAFTranslate.getTimeLeft();\n      const startCoord = parseTranslate(\n        this.waypointRef.current.style.transform,\n      );\n      const endCoord = parseTranslate(this.props.state.transform);\n      const props = {\n        startTime: performance.now(),\n        duration: transitionTime - timeLeft,\n        startCoord,\n        endCoord,\n        timingFunc: easeOutQuad,\n        nodeStyle: this.waypointRef.current.style,\n      };\n      this.draggedOnRAFTranslate = rAFTranslate(props);\n    }\n  }\n\n  handleButtonClick = e => {\n    if (this.props.isTransitioning) return;\n    e.preventDefault();\n    this.cancelLongTouch();\n    this.props.handleDelete(this.props.state.id);\n  };\n\n  getCurrGesturePageCoord = e => {\n    return e.touches && e.changedTouches[0] // check if touch event\n      ? {\n          x: e.changedTouches[0].pageX,\n          y: e.changedTouches[0].pageY,\n        }\n      : {\n          x: e.pageX,\n          y: e.pageY,\n        };\n  };\n\n  dragUpdate = () => {\n    if (!this._isMounted) return;\n    const translationVector = {\n      x: this.currGestureCoord.x - this.startGestureCoord.x,\n      y: this.currGestureCoord.y - this.startGestureCoord.y,\n    };\n    this.dragAnimating(translationVector);\n    this.props.updateWaypoints(translationVector);\n  };\n\n  updateWaypointStyle = (transform, transition) => {\n    const style = {\n      transition: `transform ${transition}ms ease`,\n      WebkitTransition: `-webkit-transform ${transition}ms ease`,\n      transform: transform,\n      WebkitTransform: transform,\n      msTransform: transform,\n    };\n    Object.assign(this.waypointRef.current.style, style);\n  };\n\n  // drag animation on touch move\n  dragAnimating = ({ x: deltaX, y: deltaY }) => {\n    const transform = `translate3d(${deltaX}px, ${deltaY}px, 0)`;\n    this.updateWaypointStyle(transform, 0);\n  };\n\n  cancelLongTouch = () => {\n    window.clearTimeout(this.longTouchTimeoutID);\n    this.longTouchTimeoutID = null;\n  };\n\n  handleGestureStart = e => {\n    if (this.props.isTransitioning || this.isDragging || this.hasDragged) {\n      return;\n    }\n    e.preventDefault();\n    if (e.touches && e.touches.length > 1) return;\n    this.hasGestureStarted = true;\n    this.startGestureCoord = this.getCurrGesturePageCoord(e);\n    this.currGestureCoord = this.startGestureCoord;\n\n    if (this.isPointerSupported) {\n      e.currentTarget.setPointerCapture(e.pointerId);\n    } else {\n      document.addEventListener('mousemove', this.handleGestureMove, true);\n      document.addEventListener('mouseup', this.handleGestureEnd, true);\n    }\n    this.longTouchTimeoutID = window.setTimeout(() => {\n      this.isDragging = true;\n      // store dragged index in parent state\n      this.props.setDragged(this.props.index);\n    }, this.longTouchWait);\n  };\n\n  handleGestureMove = e => {\n    if (!this.hasGestureStarted) return;\n    this.currGestureCoord = this.getCurrGesturePageCoord(e);\n    // check if our move is not a sloppy click\n    if (this.sloppyClick) {\n      const movedDistance = getMovedDistance(\n        this.startGestureCoord,\n        this.currGestureCoord,\n      );\n      if (movedDistance <= this.moveTriggerDelta) {\n        return;\n      }\n    }\n    this.sloppyClick = false;\n    // check if long touch has started drag\n    if (!this.isDragging) {\n      this.cancelLongTouch();\n      return;\n    }\n    // dont move if transitioning not started\n    if (!this.props.isTransitioning) {\n      return;\n    }\n    // dragging\n    e.preventDefault();\n    this.dragUpdateThrottled();\n  };\n\n  handleGestureEnd = e => {\n    this.hasGestureStarted = false;\n    // prevent during dragged end transition\n    if (this.hasDragged) return;\n\n    e.preventDefault();\n    if (e.touches && e.touches.length > 0) {\n      return;\n    }\n    if (this.isPointerSupported) {\n      e.currentTarget.releasePointerCapture(e.pointerId);\n    } else {\n      // Remove Mouse Listeners\n      document.removeEventListener('mousemove', this.handleGestureMove, true);\n      document.removeEventListener('mouseup', this.handleGestureEnd, true);\n    }\n\n    this.sloppyClick = true;\n    // cancel long touch if gesture end comes first\n    if (!this.isDragging && !this.hasDragged) {\n      this.cancelLongTouch();\n      return;\n    }\n\n    // cancel pending dragging rAF\n    this.dragUpdateThrottled.cancel();\n    // start dragged end transition\n    this.isDragging = false;\n    this.hasDragged = true;\n    const deltaY = this.props.draggedCurrRect.top - this.baseRect.top;\n    const transitionTime = this.props.state.transitionTime;\n    const startCoord = parseTranslate(this.waypointRef.current.style.transform);\n    const endCoord = {\n      x: 0,\n      y: deltaY,\n    };\n    const props = {\n      startTime: performance.now(),\n      duration: transitionTime,\n      startCoord,\n      endCoord,\n      timingFunc: easeOutQuad,\n      nodeStyle: this.waypointRef.current.style,\n    };\n    // callback after dragged end transition finishes\n    const callback = () => {\n      const transform = `translate3d(${0}px, ${0}px, 0)`;\n      this.updateWaypointStyle(transform, 0);\n      // update parent state\n      this.props.handleMoveEnd();\n    };\n    rAFTranslate(props, callback);\n  };\n\n  handleGesture = this.isPointerSupported\n    ? {\n        onPointerDown: this.handleGestureStart,\n        onPointerMove: this.handleGestureMove,\n        onPointerUp: this.handleGestureEnd,\n        onPointerCancel: this.handleGestureEnd,\n      }\n    : {\n        onMouseDown: this.handleGestureStart,\n        onTouchMove: this.handleGestureMove,\n        onTouchEnd: this.handleGestureEnd,\n      };\n\n  render() {\n    const [transform, transitionTime] = this.isDragging\n      ? // if dragging instant move\n        [this.state.transform, 0]\n      : this.hasDragged\n      ? [this.state.transform, this.props.state.transitionTime]\n      : !this.props.state.transitionTime\n      ? [this.props.state.transform, this.props.state.transitionTime]\n      : [`translate(${0}px, ${0}px)`, 0];\n    const waypointStyle = {\n      transition: `transform ${transitionTime}ms ease`,\n      WebkitTransition: `-webkit-transform ${transitionTime}ms ease`,\n      transform: transform,\n      WebkitTransform: transform,\n      msTransform: transform,\n    };\n    const waypointClass =\n      'route-waypoint__draggable' +\n      (this.isDragging ? ' route-waypoint__draggable_dragging' : '');\n    const iconClass =\n      'route-waypoint__icon' +\n      (this.isDragging ? ' route-waypoint__icon_dragging' : '');\n    return (\n      <div\n        className={'route-waypoint ' + this.props.className}\n        ref={this.routeWaypointRef}\n      >\n        <div\n          className={waypointClass}\n          style={waypointStyle}\n          ref={this.waypointRef}\n        >\n          <div\n            className={iconClass}\n            ref={this.iconRef}\n            {...this.handleGesture}\n          />\n          <div className=\"route-waypoint__name\">{this.props.state.name}</div>\n          <button\n            type=\"button\"\n            className=\"route-waypoint__button\"\n            ref={this.buttonRef}\n            onClick={this.handleButtonClick}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nRouteWaypoint.propTypes = {\n  index: PropTypes.number,\n  state: PropTypes.shape({\n    name: PropTypes.string,\n    id: PropTypes.number,\n    style: PropTypes.shape({\n      transform: PropTypes.string,\n      WebkitTransform: PropTypes.string,\n      msTransform: PropTypes.string,\n    }),\n  }),\n  className: PropTypes.string,\n  handleDelete: PropTypes.func,\n  setDragged: PropTypes.func,\n  setBaseRect: PropTypes.func,\n  updateWaypoints: PropTypes.func,\n  draggedIndex: PropTypes.number,\n  isDragging: PropTypes.bool,\n};\n\nexport default RouteWaypoint;\n","// call rAF with the latest args that have come durring queue\nexport default function rAFThrottle(func) {\n  let rafID = null;\n  let latestArgs = null;\n  const raf = (...args) => {\n    // update args of the queued func\n    latestArgs = args;\n    // dont queue if already queued\n    if (rafID) {\n      return;\n    }\n    rafID = requestAnimationFrame(() => {\n      rafID = null;\n      func(...latestArgs);\n    });\n  }\n  raf.cancel = () => {\n    if (!rafID) return;\n    window.cancelAnimationFrame(rafID);\n    rafID = null;\n  }\n  return raf;\n}\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nexport default class RouteInput extends React.Component {\n  state = {\n    text: ''\n  }\n\n  inputRef = React.createRef();\n\n  componentDidMount() {\n    if (this.props.isMapLoaded) {\n      this.inputRef.current.focus();\n      this.inputRef.current.click();\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.isMapLoaded !== this.props.isMapLoaded) {\n      this.inputRef.current.focus();\n      this.inputRef.current.click();\n    }\n  }\n\n  handleChange = (e) => {\n    this.setState({\n      text: e.target.value\n    });\n  }\n\n  handleKeyDown = (e) => {\n    if (e.key === 'Enter' && !e.repeat && e.target.value.trim()) {\n      this.props.handleEnter(e.target.value);\n      this.setState({\n        text: ''\n      });\n    }\n  }\n\n  render() {\n    return (\n      <div className={this.props.className}>\n        <input\n          type=\"text\"\n          placeholder={this.props.placeholder}\n          autoComplete=\"off\"\n          autoCorrect=\"off\"\n          onChange={this.handleChange}\n          onKeyDown={this.handleKeyDown}\n          value={this.state.text}\n          ref={this.inputRef}\n          disabled={this.props.isMapLoaded ? false : true}\n        />\n      </div>\n    );\n  }\n}\n\nRouteInput.propTypes = {\n  className: PropTypes.string,\n  handleEnter: PropTypes.func,\n  placeholder: PropTypes.string,\n  isMapLoaded: PropTypes.bool\n};","/**\n * HOF for creating abortable promise chains\n * @param {{abort: () => void}} abortToken - token used to abort promise chain with token.abort()\n * @return {(promise: Promise) => Promise} - function that returns abortable promise\n */\nconst withAbortToken = abortToken => promise =>\n  new Promise((resolve, reject) => {\n    abortToken.abort = () => {\n      resolve = null;\n      reject = null;\n    };\n    promise\n      .then(value => {\n        if (resolve) resolve(value);\n      })\n      .catch(reason => {\n        if (reject) reject(reason);\n      });\n  });\n\nexport default withAbortToken;\n","import React from 'react';\nimport './Centering.scss';\n\nexport default class Centering extends React.Component {\n  render() {\n    return (\n      <div className=\"centering-outer\" style={{ height: this.props.height }}>\n        <div className=\"centering-middle\">{this.props.children}</div>\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport withAbortToken from '../utility/withAbortToken';\nimport PropTypes from 'prop-types';\nimport './RouteMap.scss';\nimport Centering from './Centering';\n\nexport default class RouteMap extends React.Component {\n  state = {\n    isLoading: true,\n    error: null,\n    markers: [],\n    map: null,\n    polyline: null,\n    lastAction: null,\n    // viewport: {\n    //   height: '',\n    //   width: ''\n    // }\n  };\n  isPolylineAnimating = false;\n  // scrollingElement = document.scrollingElement || document.documentElement;\n\n  isGoogleApiLoaded = 'google' in window;\n  isGeolocationSupported = 'geolocation' in navigator;\n\n  googleMapRef = React.createRef();\n  googleMapApiKey = 'AIzaSyC-ij1b7n8H0QPCUPptFwUSFqzrTKbvXHc';\n\n  markerColors = {\n    start: 'https://maps.google.com/mapfiles/ms/icons/green-dot.png',\n    default: 'https://maps.google.com/mapfiles/ms/icons/yellow-dot.png',\n    end: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png',\n  };\n\n  getDefaultCenter() {\n    return { lat: 55.7558, lng: 37.6173 };\n  }\n\n  addMarker = coordinates => {\n    let icon;\n    const markersCount = this.state.markers.length;\n    if (!markersCount) {\n      icon = this.markerColors.start;\n    } else {\n      icon = this.markerColors.end;\n      if (markersCount !== 1) {\n        this.state.markers[markersCount - 1].marker.setIcon(\n          this.markerColors.default,\n        );\n      }\n    }\n    return new window.google.maps.Marker({\n      position: coordinates,\n      map: this.state.map,\n      draggable: true,\n      icon,\n    });\n  };\n\n  updateMarkerIcon(markers, index) {\n    if (index === 0) {\n      markers[index].marker.setIcon(this.markerColors.start);\n    } else if (index === markers.length - 1) {\n      markers[index].marker.setIcon(this.markerColors.end);\n    } else if (index < markers.length - 1) {\n      markers[index].marker.setIcon(this.markerColors.default);\n    }\n  }\n\n  // updateViewPortSize = () => {\n  //   this.setState({\n  //     viewport: {\n  //       height: this.scrollingElement.clientHeight,\n  //       width: this.scrollingElement.clientWidth\n  //     }\n  //   });\n  // }\n\n  async componentDidMount() {\n    // this.updateViewPortSize();\n    // window.addEventListener('resize', this.updateViewPortSize);\n\n    this.abortToken = {\n      abort: null,\n    };\n    this.withCancel = withAbortToken(this.abortToken);\n    try {\n      if (!this.isGoogleApiLoaded) {\n        await this.withCancel(this.getGoogleApi());\n        this.isGoogleApiLoaded = true;\n      }\n      let center;\n      if (this.isGeolocationSupported) {\n        try {\n          const {\n            coords: { latitude, longitude },\n          } = await this.withCancel(this.getLocation());\n          center = { lat: latitude, lng: longitude };\n        } catch (e) {\n          center = null;\n        }\n      }\n      if (!center) center = this.getDefaultCenter();\n      const options = {\n        center,\n        zoom: 8,\n      };\n      const map = new window.google.maps.Map(\n        this.googleMapRef.current,\n        options,\n      );\n      this.setState({ map });\n      this.props.onMapLoad();\n    } catch (error) {\n      this.setState({\n        error,\n      });\n    } finally {\n      this.setState({\n        isLoading: false,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.abortToken.abort){\n    this.abortToken.abort();\n  }\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const { id, action, name, newIndex } = this.props.payload;\n    const { id: prevID } = prevProps.payload;\n    let newMarkers = null;\n    if (action === 'ADD' && id !== prevID) {\n      // ADD marker block\n      // create and add marker to the map\n      const coordinates = this.state.map.getCenter().toJSON();\n      const marker = this.addMarker(coordinates);\n      // add event listener to marker to animate polyline on drag\n      marker.addListener('drag', () => {\n        this.isPolylineAnimating = true;\n        window.requestAnimationFrame(this.dragPolylineAnimation);\n      });\n      // create popup\n      const popup = new window.google.maps.InfoWindow();\n      // add popup to the marker\n      marker.addListener('click', async () => {\n        const coordinates = marker.getPosition().toJSON();\n        const address = await this.reverseGeocode(coordinates);\n        const content = `\n        <div class=\"route-map__popup\">\n          <div class=\"route-map__popup__name\">${name}</div>\n          ${\n            address\n              ? `<div class=\"route-map__popup__address\">${\n                  address.formatted_address\n                }</div>`\n              : ``\n          }\n        </div>`;\n        popup.setContent(content);\n        popup.open(this.state.map, marker);\n      });\n      //add marker to markers array\n      newMarkers = [...this.state.markers, { id, marker }];\n    } else if (\n      action === 'DELETE' &&\n      prevState.markers.length === this.state.markers.length\n    ) {\n      // DELETE marker block\n      const markerIndex = this.state.markers.findIndex(\n        marker => marker.id === id,\n      );\n      if (markerIndex === -1) return;\n      this.state.markers[markerIndex].marker.setMap(null);\n      newMarkers = [\n        ...this.state.markers.slice(0, markerIndex),\n        ...this.state.markers.slice(markerIndex + 1),\n      ];\n      if (markerIndex === newMarkers.length && newMarkers.length !== 0) {\n        // if last item has been deleted than update only last marker of a non empty array\n        this.updateMarkerIcon(newMarkers, newMarkers.length - 1);\n      } else if (!markerIndex && newMarkers.length !== 0) {\n        // if first item has been deleted than update only first marker of a non empty array\n        this.updateMarkerIcon(newMarkers, 0);\n      }\n    } else if (action === 'MOVE' && this.state.markers[newIndex].id !== id) {\n      // MOVE marker block\n      const oldIndex = this.state.markers.findIndex(m => m.id === id);\n      newMarkers = [...this.state.markers];\n      const draggedMarker = newMarkers.splice(oldIndex, 1)[0];\n      newMarkers.splice(newIndex, 0, draggedMarker);\n      for (\n        let i = Math.min(oldIndex, newIndex);\n        i <= Math.max(oldIndex, newIndex);\n        i++\n      ) {\n        this.updateMarkerIcon(newMarkers, i);\n      }\n    }\n    // get new polyline\n    let polyline;\n    if (\n      (newMarkers && newMarkers.length !== this.state.markers.length) ||\n      (action === 'MOVE' && this.state.markers[newIndex].id !== id)\n    ) {\n      polyline = this.updatePolyline(newMarkers);\n      this.setState({\n        markers: newMarkers,\n        polyline,\n        lastAction: action,\n      });\n    }\n    if (this.state.lastAction === 'POLYLINE') {\n      this.setState({\n        lastAction: null,\n      });\n    }\n  }\n\n  reverseGeocode = async location => {\n    try {\n      const geocoder = new window.google.maps.Geocoder();\n      return await new Promise((resolve, reject) => {\n        geocoder.geocode({ location: location }, (results, status) => {\n          if (status === 'OK') {\n            resolve(results[0]);\n          } else {\n            reject(status);\n          }\n        });\n      });\n    } catch (err) {\n      return null;\n    }\n  };\n\n  updatePolyline = markers => {\n    // clear polyline\n    if (this.state.polyline) this.state.polyline.setMap(null);\n    // draw lines if more than 1 marker\n    if (markers.length > 1) {\n      // get path array\n      const path = markers.map(marker => marker.marker.getPosition().toJSON());\n      // create new polyline\n      const polyline = new window.google.maps.Polyline({\n        path,\n        geodesic: true,\n        strokeColor: '#FF0000',\n        strokeOpacity: 1.0,\n        strokeWeight: 2,\n      });\n      polyline.setMap(this.state.map);\n      return polyline;\n    }\n    return null;\n  };\n\n  dragPolylineAnimation = () => {\n    if (!this.isPolylineAnimating) return;\n    this.setState(\n      prevState => {\n        const polyline = this.updatePolyline(prevState.markers);\n        return {\n          polyline,\n          lastAction: 'POLYLINE',\n        };\n      },\n      () => (this.isPolylineAnimating = false),\n    );\n  };\n\n  async getGoogleApi() {\n    try {\n      return await new Promise((resolve, reject) => {\n        const googleApi = document.createElement('script');\n        const key = this.googleMapApiKey;\n        googleApi.src = `https://maps.googleapis.com/maps/api/js?key=${key}`;\n        googleApi.type = 'text/javascript';\n        googleApi.async = false;\n        googleApi.onload = e => resolve('google api loaded');\n        googleApi.onerror = e => reject(new Error(e));\n        document.body.appendChild(googleApi);\n      });\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  getLocation = async () => {\n    try {\n      const position = await new Promise((resolve, reject) => {\n        navigator.geolocation.getCurrentPosition(\n          location => resolve(location),\n          () => reject(Error('geolocation blocked')),\n        );\n      });\n      return position;\n    } catch (err) {\n      throw err;\n    }\n  };\n\n  render() {\n    const mapStyle =\n      this.state.isLoading || this.state.error\n        ? { display: 'none' }\n        : { display: 'block' };\n    // const mapStyle = {\n    //   ...this.state.viewport\n    // }\n    return (\n      <div className={'route-map ' + this.props.className}>\n        {this.state.isLoading && (\n          <Centering>\n            <div className=\"route-map__loading\">Loading</div>\n          </Centering>\n        )}\n        {this.state.error && (\n          <Centering>\n            <div className=\"route-map__error\">{this.state.error.message}</div>\n          </Centering>\n        )}\n        <div\n          className=\"route-map__map\"\n          style={mapStyle}\n          ref={this.googleMapRef}\n        />\n      </div>\n    );\n  }\n}\n\nRouteMap.propTypes = {\n  className: PropTypes.string,\n  payload: PropTypes.shape({\n    id: PropTypes.number,\n    name: PropTypes.string,\n    action: PropTypes.string,\n    newIndex: PropTypes.number,\n  }),\n};\n","type Rect = {\n  top: number;\n  bottom: number;\n  left: number;\n  right: number;\n};\n\nexport function isRect(rect: Rect): boolean {\n  return rect.top < rect.bottom && rect.left < rect.right;\n}\n\nexport function calcRectArea(rect: Rect): number | null {\n  return isRect(rect)\n    ? (rect.bottom - rect.top) * (rect.right - rect.left)\n    : null;\n}\n\nexport function doRectIntersect(rect1: Rect, rect2: Rect): boolean {\n  return (\n    isRect(rect1) &&\n    isRect(rect2) &&\n    !(\n      rect1.top >= rect2.bottom || // rect1 under rect2\n      rect1.bottom <= rect2.top || // rect1 over rect2\n      rect1.left >= rect2.right || // rect1 to the right of rect2\n      // rect1 to the left of rect2\n      rect1.right <= rect2.left\n    )\n  );\n}\n\nexport function calcIntersectionRect(rect1: Rect, rect2: Rect): Rect | null {\n  return doRectIntersect(rect1, rect2)\n    ? {\n        top: Math.max(rect1.top, rect2.top),\n        bottom: Math.min(rect1.bottom, rect2.bottom),\n        left: Math.max(rect1.left, rect2.left),\n        right: Math.min(rect1.right, rect2.right),\n      }\n    : null;\n}\n","import React from 'react';\nimport RouteWaypoint from './RouteWaypoint';\nimport RouteInput from './RouteInput';\nimport RouteMap from './RouteMap';\nimport Centering from './Centering';\nimport './MapRouteCreation.scss';\nimport {\n  calcRectArea,\n  calcIntersectionRect,\n} from '../utility/rectangle-utility';\n\nexport default class MapRouteCreation extends React.Component {\n  state = {\n    hasMoved: false,\n    isMaxWaypointsReached: false,\n    isMapLoaded: false,\n    waypoints: [],\n    id: 0,\n    isTransitioning: false,\n    draggedIndex: null,\n    mapPayload: {\n      id: null,\n      newIndex: null,\n      action: '',\n      name: '',\n    },\n  };\n\n  waypointsRects = [];\n\n  transitionTime = 300;\n\n  isPointerSupported = Boolean(window.PointerEvent);\n\n  componentDidMount() {\n    this._isMounted = true;\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    // on transition ends\n    if (\n      prevState.isTransitioning === true &&\n      this.state.isTransitioning === false\n    ) {\n      // update transition time for moved wps\n      const newWaypoints = [...this.state.waypoints];\n      for (\n        let i = Math.min(this.state.draggedCurrIndex, this.state.draggedIndex);\n        i <= Math.max(this.state.draggedCurrIndex, this.state.draggedIndex);\n        i++\n      ) {\n        newWaypoints[i].transitionTime = this.transitionTime;\n      }\n      this.setState({\n        waypoints: newWaypoints,\n      });\n    }\n  }\n\n  handleEnter = value => {\n    this.setState(prevState => {\n      if (prevState.waypoints.length === 15) {\n        return {\n          isMaxWaypointsReached: true,\n        };\n      }\n      return {\n        waypoints: [\n          ...prevState.waypoints,\n          {\n            name: value,\n            id: prevState.id,\n            transform: `translate(${0}px, ${0}px)`,\n            transitionTime: this.transitionTime,\n          },\n        ],\n        id: prevState.id + 1,\n        mapPayload: {\n          id: prevState.id,\n          action: 'ADD',\n          name: value,\n        },\n      };\n    });\n  };\n\n  handleDelete = id => {\n    this.waypointsRects = this.waypointsRects.filter(wp => wp.id !== id);\n    this.setState(prevState => ({\n      waypoints: prevState.waypoints.filter(wp => wp.id !== id),\n      isMaxWaypointsReached: false,\n      mapPayload: {\n        id,\n        action: 'DELETE',\n      },\n    }));\n  };\n\n  setBaseRect = (index, baseRect) => {\n    this.waypointsRects[index] = baseRect;\n  };\n\n  setDragged = index => {\n    this.setState({\n      isTransitioning: true,\n      draggedCurrRect: this.waypointsRects[index],\n      draggedCurrIndex: index,\n      draggedIndex: index,\n      mapPayload: {\n        action: '',\n      },\n    });\n  };\n\n  /**\n   * Update waypoints during waypoint dragging\n   * @param {{x: Number, y: Number}} translationVector\n   * @returns {void}\n   */\n  updateWaypoints = translationVector => {\n    const { hasMoved, draggedIndex, draggedCurrIndex } = this.state;\n    const draggedOnIndex = this.findDraggedOn(translationVector);\n    // ignore currently dragged on position\n    if (draggedOnIndex !== null && draggedOnIndex !== draggedCurrIndex) {\n      this.handleMove(draggedOnIndex);\n    } else if (draggedOnIndex === null && hasMoved) {\n      // dragged wp left dragged on position\n      this.handleMove(draggedIndex);\n    }\n  };\n\n  /**\n   * Find dragged on waypoint\n   * consider waypoints dragged on only\n   * when intersection area with dragged waypoint\n   * is bigger than areaFraction of waypoint's area\n   * @param {{x: Number, y: Number}} translationVector\n   * @param {Number} [wpAreaFraction=0.25]\n   * @returns {number|null} -\n   */\n  findDraggedOn = ({ x, y }, wpAreaFraction = 0.33) => {\n    const { waypoints, draggedIndex } = this.state;\n    let draggedOnIndex = null;\n    waypoints.every((wp, index) => {\n      // skip dragged waypoint\n      if (index === draggedIndex) {\n        return true;\n      }\n      // calc the current coordinates of dragging rect\n      const draggedBaseRect = this.waypointsRects[draggedIndex];\n      const draggedRect = {\n        top: draggedBaseRect.top + y,\n        bottom: draggedBaseRect.bottom + y,\n        left: draggedBaseRect.left + x,\n        right: draggedBaseRect.right + x,\n      };\n      // calc intersection rect between dragged and potential dragged on\n      const draggedOnRect = this.waypointsRects[index];\n      const intersectionRect = calcIntersectionRect(draggedOnRect, draggedRect);\n      // move waypoint if dragged wp coveres more than wpAreaFraction of dragged on wp area\n      if (\n        intersectionRect &&\n        calcRectArea(intersectionRect) >\n          wpAreaFraction * calcRectArea(draggedOnRect)\n      ) {\n        draggedOnIndex = index;\n        return false;\n      }\n      return true;\n    });\n    return draggedOnIndex;\n  };\n\n  handleMove = newIndex => {\n    this.setState(prevState => {\n      const newWaypoints = [...prevState.waypoints];\n      const initIndex = prevState.draggedIndex;\n      const currIndex = prevState.draggedCurrIndex;\n      let transform;\n      let hasMoved = true;\n      // calculate translate distance depending on move direction\n      const isNewInside =\n        // init ... new ... curr\n        (initIndex < newIndex && newIndex < currIndex) ||\n        // curr ... new ... init\n        (currIndex < newIndex && newIndex < initIndex);\n      const isNewOutSide =\n        // init ... curr ... new\n        (initIndex < currIndex && currIndex < newIndex) ||\n        // new ... curr ... init\n        (newIndex < currIndex && currIndex < initIndex);\n      if (!this.state.hasMoved || isNewOutSide) {\n        const deltaY =\n          currIndex < newIndex\n            ? this.waypointsRects[currIndex + 1].top -\n              this.waypointsRects[currIndex].top\n            : this.waypointsRects[currIndex - 1].bottom -\n              this.waypointsRects[currIndex].bottom;\n        transform = `translate(${0}px, ${-deltaY}px)`;\n      } else if (isNewInside || newIndex === initIndex) {\n        if (newIndex === initIndex) {\n          hasMoved = false;\n        }\n        transform = `translate(${0}px, ${0}px)`;\n      } else {\n        return;\n      }\n      const isGoingUP = newIndex > currIndex;\n      for (\n        let i = currIndex;\n        isGoingUP ? i <= newIndex : i >= newIndex;\n        isGoingUP ? i++ : i--\n      ) {\n        if (i === initIndex || (isNewInside && i === newIndex)) continue;\n        newWaypoints[i] = {\n          ...newWaypoints[i],\n          transform,\n        };\n      }\n      // update curr dragged index\n      const draggedCurrIndex = newIndex;\n      // get dragged id for map\n      const draggedID = prevState.waypoints[initIndex].id;\n      // get potentional next rect for dragged waypoint so we can properly animate on drag end\n      const draggedCurrRect = this.waypointsRects[newIndex];\n      return {\n        hasMoved,\n        draggedCurrIndex,\n        draggedCurrRect,\n        waypoints: newWaypoints,\n        mapPayload: {\n          id: draggedID, // TODO: refactor to pass index\n          newIndex,\n          action: 'MOVE',\n        },\n      };\n    });\n  };\n\n  handleMoveEnd = () => {\n    this.setState(prevState => {\n      const newWaypoints = [...prevState.waypoints];\n      // move dragged waypoint to the new position\n      const draggedWaypoint = newWaypoints.splice(\n        this.state.draggedIndex,\n        1,\n      )[0];\n      newWaypoints.splice(this.state.draggedCurrIndex, 0, draggedWaypoint);\n      // reset transform and transition to 0 for instant render in new positions\n      const transform = `translate3d(${0}px, ${0}px, 0)`;\n      const transitionTime = 0;\n      // update all moved waypoints\n      for (\n        let i = Math.min(this.state.draggedCurrIndex, this.state.draggedIndex);\n        i <= Math.max(this.state.draggedCurrIndex, this.state.draggedIndex);\n        i++\n      ) {\n        newWaypoints[i] = {\n          ...newWaypoints[i],\n          transform,\n          transitionTime,\n        };\n      }\n      return {\n        hasMoved: false,\n        isTransitioning: false,\n        waypoints: newWaypoints,\n      };\n    });\n  };\n\n  handleMapLoad = () =>\n    this.setState({\n      isMapLoaded: true,\n    });\n\n  render() {\n    const waypoints = this.state.waypoints.map((wp, index) => (\n      <RouteWaypoint\n        key={wp.id.toString()}\n        index={index}\n        state={wp}\n        className=\"map-route-creation__waypoint\"\n        handleDelete={this.handleDelete}\n        handleMoveEnd={this.handleMoveEnd}\n        setDragged={this.setDragged}\n        // draggedIndex={this.state.draggedIndex}\n        draggedCurrRect={\n          index === this.state.draggedIndex ? this.state.draggedCurrRect : null\n        }\n        isTransitioning={this.state.isTransitioning}\n        setBaseRect={this.setBaseRect}\n        updateWaypoints={this.updateWaypoints}\n      />\n    ));\n    const waypointsClass = `map-route-creation__waypoints ${\n      this.state.isDragStarted ? 'map-route-creation__waypoints_dragging' : ''\n    }`;\n    return (\n      <Centering height=\"100vh\">\n        <div className=\"map-route-creation\">\n          <div className=\"map-route-creation__content\">\n            <RouteInput\n              className=\"map-route-creation__input\"\n              handleEnter={this.handleEnter}\n              placeholder=\"Новая точка маршрута\"\n              isMapLoaded={this.state.isMapLoaded}\n            />\n            <div className={waypointsClass}>{waypoints}</div>\n            {this.state.isMaxWaypointsReached && (\n              <div className=\"map-route-creation__warning\">\n                15 точек максимум\n              </div>\n            )}\n          </div>\n          <RouteMap\n            className=\"map-route-creation__map\"\n            payload={this.state.mapPayload}\n            onMapLoad={this.handleMapLoad}\n          />\n        </div>\n      </Centering>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport './App.scss';\nimport MapRouteCreation from './MapRouteCreation';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <MapRouteCreation />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import 'react-app-polyfill/ie9';\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.scss';\r\nimport App from './Components/App';\r\n\r\nReactDOM.render(\r\n  <App />\r\n  ,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}